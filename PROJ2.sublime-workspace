{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"open",
				"opening"
			],
			[
				"Get",
				"GetComponent"
			],
			[
				"Pas",
				"Pas_Rotation"
			],
			[
				"next",
				"nextRotation"
			],
			[
				"net",
				"nextRotation"
			]
		]
	},
	"buffers":
	[
		{
			"file": "test.py",
			"settings":
			{
				"buffer_size": 212,
				"encoding": "UTF-8",
				"line_ending": "Windows",
				"name": "import numpy as np"
			}
		},
		{
			"contents": "import sys\nimport numpy as np\nimport cv2\n\n# Read points from text file\ndef readPoints(path) :\n    # Create an array of points.\n    points = [];\n    \n    # Read points\n    with open(path) as file :\n        for line in file :\n            x, y = line.split()\n            points.append((int(x), int(y)))\n    \n\n    return points\n\n# Apply affine transform calculated using srcTri and dstTri to src and\n# output an image of size.\ndef applyAffineTransform(src, srcTri, dstTri, size) :\n    \n    # Given a pair of triangles, find the affine transform.\n    warpMat = cv2.getAffineTransform( np.float32(srcTri), np.float32(dstTri) )\n    \n    # Apply the Affine Transform just found to the src image\n    dst = cv2.warpAffine( src, warpMat, (size[0], size[1]), None, flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT_101 )\n\n    return dst\n\n\n# Check if a point is inside a rectangle\ndef rectContains(rect, point) :\n    if point[0] < rect[0] :\n        return False\n    elif point[1] < rect[1] :\n        return False\n    elif point[0] > rect[0] + rect[2] :\n        return False\n    elif point[1] > rect[1] + rect[3] :\n        return False\n    return True\n\n\n#calculate delanauy triangle\ndef calculateDelaunayTriangles(rect, points):\n    #create subdiv\n    subdiv = cv2.Subdiv2D(rect);\n    \n    # Insert points into subdiv\n    for p in points:\n        subdiv.insert(p) \n    \n    triangleList = subdiv.getTriangleList();\n    \n    delaunayTri = []\n    \n    pt = []    \n        \n    for t in triangleList:        \n        pt.append((t[0], t[1]))\n        pt.append((t[2], t[3]))\n        pt.append((t[4], t[5]))\n        \n        pt1 = (t[0], t[1])\n        pt2 = (t[2], t[3])\n        pt3 = (t[4], t[5])        \n        \n        if rectContains(rect, pt1) and rectContains(rect, pt2) and rectContains(rect, pt3):\n            ind = []\n            #Get face-points (from 68 face detector) by coordinates\n            for j in range(0, 3):\n                for k in range(0, len(points)):                    \n                    if(abs(pt[j][0] - points[k][0]) < 1.0 and abs(pt[j][1] - points[k][1]) < 1.0):\n                        ind.append(k)    \n            # Three points form a triangle. Triangle array corresponds to the file tri.txt in FaceMorph \n            if len(ind) == 3:                                                \n                delaunayTri.append((ind[0], ind[1], ind[2]))\n        \n        pt = []        \n            \n    \n    return delaunayTri\n        \n\n# Warps and alpha blends triangular regions from img1 and img2 to img\ndef warpTriangle(img1, img2, t1, t2) :\n\n    # Find bounding rectangle for each triangle\n    r1 = cv2.boundingRect(np.float32([t1]))\n    r2 = cv2.boundingRect(np.float32([t2]))\n\n    # Offset points by left top corner of the respective rectangles\n    t1Rect = [] \n    t2Rect = []\n    t2RectInt = []\n\n    for i in range(0, 3):\n        t1Rect.append(((t1[i][0] - r1[0]),(t1[i][1] - r1[1])))\n        t2Rect.append(((t2[i][0] - r2[0]),(t2[i][1] - r2[1])))\n        t2RectInt.append(((t2[i][0] - r2[0]),(t2[i][1] - r2[1])))\n\n\n    # Get mask by filling triangle\n    mask = np.zeros((r2[3], r2[2], 3), dtype = np.float32)\n    cv2.fillConvexPoly(mask, np.int32(t2RectInt), (1.0, 1.0, 1.0), 16, 0);\n\n    # Apply warpImage to small rectangular patches\n    img1Rect = img1[r1[1]:r1[1] + r1[3], r1[0]:r1[0] + r1[2]]\n    #img2Rect = np.zeros((r2[3], r2[2]), dtype = img1Rect.dtype)\n    \n    size = (r2[2], r2[3])\n\n    img2Rect = applyAffineTransform(img1Rect, t1Rect, t2Rect, size)\n    \n    img2Rect = img2Rect * mask\n\n    # Copy triangular region of the rectangular patch to the output image\n    img2[r2[1]:r2[1]+r2[3], r2[0]:r2[0]+r2[2]] = img2[r2[1]:r2[1]+r2[3], r2[0]:r2[0]+r2[2]] * ( (1.0, 1.0, 1.0) - mask )\n     \n    img2[r2[1]:r2[1]+r2[3], r2[0]:r2[0]+r2[2]] = img2[r2[1]:r2[1]+r2[3], r2[0]:r2[0]+r2[2]] + img2Rect \n    \n\nif __name__ == '__main__' :\n    \n    # Make sure OpenCV is version 3.0 or above\n    (major_ver, minor_ver, subminor_ver) = (cv2.__version__).split('.')\n\n    if int(major_ver) < 3 :\n        print >>sys.stderr, 'ERROR: Script needs OpenCV 3.0 or higher'\n        sys.exit(1)\n\n    # Read images\n    filename1 = 'hillary_clinton.jpg'\n    filename2 = 'donald_trump.jpg'\n    \n    img1 = cv2.imread(filename1);\n    img2 = cv2.imread(filename2);\n    img1Warped = np.copy(img2);    \n    \n    # Read array of corresponding points\n    points1 = readPoints(filename1 + '.txt')\n    points2 = readPoints(filename2 + '.txt')    \n    \n    # Find convex hull\n    hull1 = []\n    hull2 = []\n\n    hullIndex = cv2.convexHull(np.array(points2), returnPoints = False)\n          \n    for i in range(0, len(hullIndex)):\n        hull1.append(points1[int(hullIndex[i])])\n        hull2.append(points2[int(hullIndex[i])])\n    \n    \n    # Find delanauy traingulation for convex hull points\n    sizeImg2 = img2.shape    \n    rect = (0, 0, sizeImg2[1], sizeImg2[0])\n     \n    dt = calculateDelaunayTriangles(rect, hull2)\n    \n    if len(dt) == 0:\n        quit()\n    \n    # Apply affine transformation to Delaunay triangles\n    for i in range(0, len(dt)):\n        t1 = []\n        t2 = []\n        \n        #get points for img1, img2 corresponding to the triangles\n        for j in range(0, 3):\n            t1.append(hull1[dt[i][j]])\n            t2.append(hull2[dt[i][j]])\n        \n        warpTriangle(img1, img1Warped, t1, t2)\n    \n            \n    # Calculate Mask\n    hull8U = []\n    for i in range(0, len(hull2)):\n        hull8U.append((hull2[i][0], hull2[i][1]))\n    \n    mask = np.zeros(img2.shape, dtype = img2.dtype)  \n    \n    cv2.fillConvexPoly(mask, np.int32(hull8U), (255, 255, 255))\n    \n    r = cv2.boundingRect(np.float32([hull2]))    \n    \n    center = ((r[0]+int(r[2]/2), r[1]+int(r[3]/2)))\n        \n    \n    # Clone seamlessly.\n    output = cv2.seamlessClone(np.uint8(img1Warped), img2, mask, center, cv2.NORMAL_CLONE)\n    \n    cv2.imshow(\"Face Swapped\", output)\n    cv2.waitKey(0)\n    \n    cv2.destroyAllWindows()",
			"file": "Nabil/FaceSwapping_Nabil.py",
			"file_size": 6126,
			"file_write_time": 132259950851591295,
			"settings":
			{
				"buffer_size": 5932,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/acer/Documents/GitHub/PROJ2",
		"/C/Users/acer/Documents/GitHub/PROJ2/Images"
	],
	"file_history":
	[
		"/C/Users/acer/Desktop/PROJET/FaceSwapping_Nabil.py",
		"/C/Users/acer/Documents/GitHub/PROJ2/Scripts/cmake.exe",
		"/C/Users/acer/Dev/cfehome/cfehome",
		"/C/Users/acer/Desktop/Unity jeux/Tuto/Assets/Ouvrir.cs",
		"/C/Users/acer/Desktop/TP C++/TP11/main.cc",
		"/C/Users/acer/Desktop/ESIR2/CIN/TP Projet/scene-Copie.g",
		"/C/Users/acer/Downloads/tp_contours.cpp",
		"/C/Users/acer/Desktop/ESIR2/SI/BVH_Bastien.cpp",
		"/C/Users/acer/Desktop/TP C++/TP11/test_p1.cc",
		"/C/Users/acer/Desktop/Unity jeux/Tuto/Assets/Interrupteur.cs",
		"/C/Users/acer/Desktop/Unity jeux/Tuto/Assets/ArcherMotor.cs",
		"/C/Users/acer/Desktop/Unity jeux/Tuto/Assets/Lien.cs",
		"/C/Users/acer/Desktop/Test sites/style.css",
		"/C/Users/acer/Desktop/Unity jeux/Tuto/Assets/Prefabs tests/Scripts/Cube_Movement.cs",
		"/C/Users/acer/Documents/Game Jam Git/game/SKooby-SKwad/Assets/Scripts/DeplacementBleu.cs",
		"/C/Users/acer/Desktop/Test sites/test.html",
		"/C/Users/acer/Documents/Game Jam Git/game/SKooby-SKwad/Assets/Scripts/Collecte.cs",
		"/C/Users/acer/Documents/Game Jam Git/game/SKooby-SKwad/Assets/RandomSpawn.cs",
		"/C/Users/acer/Desktop/Unity jeux/Tuto/Assets/test.cs",
		"/C/Users/acer/Desktop/Test sites/Liens.html"
	],
	"find":
	{
		"height": 23.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"xrange"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "test.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 212,
						"regions":
						{
						},
						"selection":
						[
							[
								69,
								69
							]
						],
						"settings":
						{
							"auto_name": "import numpy as np",
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Nabil/FaceSwapping_Nabil.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5932,
						"regions":
						{
						},
						"selection":
						[
							[
								4997,
								4997
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 35.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "PROJ2.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
